last_char := ' '
spaces_per_tab :: 4

func move_reset(x, y) {
    last_char = ' '
    move(x, y)
}

func file_opened(name) {
    set_status("Opened file %s", name)
}

func count_braces_in_line(line_index) {
    line := get_line(line_index)
    len := strlen(line)

    inside_quotes := false

    braces := 0

    for i := 0; i < len; i += 1 {
        if stridx(line, i) == '"' {
            inside_quotes = not inside_quotes
        } else if stridx(line, i) == '\'' {
            i += 2
        } else if not inside_quotes {
            c := stridx(line, i)
            if c == '{' braces += 1
            else if c == '}' braces -= 1
        }
    }

    return braces
}

func count_braces_down(to_line) {
    braces := 0

    for i := 0; i < to_line; i += 1 {
        braces += count_braces_in_line(i)
    }

    return braces
}

func apply_brace_indent() {
    spaces := count_braces_down(get_y()) * 4

    move_to(0, get_y())

    for i := 0; i < spaces; i += 1 { 
        insert_char(' ')
        move(1, 0)
    }
}

func update_normal_mode() {
    ch := read_char()

    if last_char == 'r' and ch > 0 {
        set_char(ch)
        last_char = ' '
        return;
    }

    if ch == 'V' {
        set_mode(MODE_VISUAL_LINE)
        return;
    }
    
    if ch == 'i' {
        set_mode(MODE_INSERT)
        return;
    }

    if ch == 'a' {
        set_mode(MODE_INSERT)
        move(1, 0)
        return;
    }

    if ch == 'A' {
        set_mode(MODE_INSERT)
        move(strlen(get_line()), 0)
        return;
    }

    if ch == 'o' {
        set_mode(MODE_INSERT)
        insert_empty_line(get_y() + 1)
        move(0, 1)
        apply_brace_indent()
        return;
    }

    if ch == 'O' {
        set_mode(MODE_INSERT)
        insert_empty_line()
        apply_brace_indent()
        return;
    }

    if ch == 'e' {
        i := get_x()
        s := get_line()
        len := strlen(s)

        while i >= len - 1 or strspn(s, " ") == len {
            move_to(0, get_y() + 1)

            i = get_x()
            s = get_line()
            len = strlen(s)
        }

        if i < len - 1 {
            if stridx(s, i + 1) == ' ' {
                i += 1

                while stridx(s, i) == ' ' and i < len {
                    i += 1
                }

                i += 1
            } else {
                while stridx(s, i) != ' ' and i < len {
                    i += 1
                }
            }

            move_to(i - 1, get_y())
        }

        last_char = ' '
    }

    if ch == 'b' {
        i := get_x()
        s := get_line()
        
        if i > 0 {
            if i - 1 >= 0 and stridx(s, i - 1) == ' ' {
                i -= 1
                while stridx(s, i) == ' ' and i >= 0 {
                    i -= 1
                }

                move_to(i, get_y())
            } else {
                while stridx(s, i) != ' ' and i >= 0 {
                    i -= 1
                }

                move_to(i + 1, get_y())
            }
        }

        last_char = ' '
    }

    if ch == 'd' {
        if get_mode() == MODE_VISUAL_LINE {
            // TODO(Apaar): Delete range
        } else {
            if last_char == 'd' {
                if line_count() > 1 remove_line()
                last_char = ' '
            } else {
                last_char = 'd'
            }
        }
    }

    if ch == 'h' {
        move_reset(-1, 0)
    } else if ch == 'j' {
        move_reset(0, 1)
    } else if ch == 'k' {
        move_reset(0, -1)
    } else if ch == 'l' {
        move_reset(1, 0)
    } 
 
    if ch == '{' {
        done := false
        for i := get_y() - 1; i >= 0 and not done; i -= 1 {
            if get_line(i) == "" {
                move(0, i - get_y())
                done = true
            }
        }
        
        if not done {
            move(0, -line_count())
        }
    } else if ch == '}' {
        done := false
        for i := get_y() + 1; i < line_count() and not done; i += 1 {
            if get_line(i) == "" {
                move(0, i - get_y())
                done = true
            }
        }
        
        if not done {
            move(0, line_count())
        }
    }
    
    if ch == 'G' {
        move_reset(0, line_count())
        set_status("To the bottom!")
    } else if ch == 'g' {
        if last_char == 'g' {
            set_status("To the top!")
            move_reset(0, -line_count())
        } else {
            last_char = 'g'
        }
    } 

    if ch == 'r' {
        last_char = 'r'
    }
}

func update_insert_mode() {
    ch := read_char()

    if ch == 27 {
        set_mode(MODE_NORMAL)
    } else if ch == 8 {
        // backspace
        if get_x() == 0 {
            if get_y() > 0 {
                s := get_line()

                move_to(0, get_y() - 1)
                move(strlen(get_line()), 0)

                insert_string(s)
                remove_line(get_y() + 1)
            }
        } else {
            // if there's only spaces before us, maybe we can move back by
            // tab width
            spaces_only := true

            s := get_line()
            x := get_x() - 1

            for i := 0; i < x and spaces_only; i += 1 {
                if stridx(s, i) != ' ' {
                    spaces_only = false
                }
            }
            
            if not spaces_only {
                move(-1, 0)
                remove_char()
            } else {
                spaces := get_x() - floor((get_x() - 1) / spaces_per_tab) * spaces_per_tab

                for i := 0; i < spaces; i += 1 {
                    move(-1, 0)
                    remove_char()
                }
            }
        }
    } else if ch == 10 {
        x := get_x()
        
        if x == strlen(get_line()) {
            insert_empty_line(get_y() + 1)
            move(0, 1)
        } else {
            rest := get_line_from(get_x()) 
            move(0, 1)

            insert_empty_line()
            insert_string(rest)

            terminate_line(get_y() - 1, x)
        }
        apply_brace_indent()
    } else if ch > 0 {
        if ch == 9 {
            spaces := ceil((get_x() + 1) / spaces_per_tab) * spaces_per_tab - get_x()

            for i := 0; i < spaces; i += 1 {
                insert_char(' ')
            }

            move(spaces, 0)
        } else {
            insert_char(ch)
            move(1, 0)

            if ch == '}' {
                line := get_line()
                if stridx(line, strspn(line, " ")) == '}' {
                    // Spaces all the way 
                    spaces := (count_braces_down(get_y()) - 1) * spaces_per_tab

                    if spaces >= 0 {
                        terminate_line(get_y(), spaces + 1)
                        move_to(spaces, get_y())
                        set_char('}')
                        move(1, 0)
                    }
                }
            }
        }
    }
}

func update() {
    if get_mode() == MODE_INSERT update_insert_mode()
    else if get_mode() == MODE_NORMAL or get_mode() == MODE_VISUAL_LINE update_normal_mode()
}
