last_char := ' '
spaces_per_tab :: 4

func move_reset(x, y) {
    last_char = ' '
    move(x, y)
}

func file_opened(name) {
    set_status("Opened file %s", name)
}

func count_braces_in_line(line_index) {
    line := get_line(line_index)
    len := strlen(line)

    inside_quotes := false
    inside_comment := false

    braces := 0

    for i := 0; i < len; i += 1 {
        if stridx(line, i) == '"' {
            inside_quotes = not inside_quotes
        } else if stridx(line, i) == '\'' {
            i += 2
        } else if not inside_quotes {
            c := stridx(line, i)
            if c == '{' braces += 1
            else if c == '}' braces -= 1
        }
    }

    return braces
}

func count_braces_down(to_line) {
    braces := 0

    for i := 0; i < to_line; i += 1 {
        braces += count_braces_in_line(i)
    }

    return braces
}

func apply_brace_indent() {
    spaces := count_braces_down(get_y()) * spaces_per_tab

    move_to(0, get_y())

    for i := 0; i < spaces; i += 1 { 
        insert_char(' ')
        move(1, 0)
    }
}

func get_prev_word_x() {
    i := get_x()
    s := get_line()
    
    if i > 0 {
        if i - 1 >= 0 and stridx(s, i - 1) == ' ' {
            i -= 1
            while stridx(s, i) == ' ' and i >= 0 {
                i -= 1
            }

            return i
        } else {
            while stridx(s, i) != ' ' and i >= 0 {
                i -= 1
            }

            return i + 1
        }
    } else {
        return i
    }
}

func get_next_word_x() {
    i := get_x()
    s := get_line()
    len := strlen(s)
     
    if i < len - 1 {
        if stridx(s, i + 1) == ' ' {
            i += 1
            
            while stridx(s, i) == ' ' and i < len {
                i += 1
            }
            
            return i
        } else {
            while stridx(s, i) != ' ' and i < len {
               i += 1
           }

           return i - 1
       }
    } else {
        return i
    }
}

func update_normal_mode() {
    ch := read_char()

    if last_char == 'r' and ch > 0 {
        set_char(ch)
        last_char = ' '
        return;
    }
    
    if ch == 27 {
        set_mode(MODE_NORMAL)
        return;
    }

    if ch == 'V' {
        set_mode(MODE_VISUAL_LINE)
        return;
    }
    
    if ch == 'i' {
        set_mode(MODE_INSERT)
        return;
    }

    if ch == 'I' {
        set_mode(MODE_INSERT)
        move_to(strspn(get_line(), " "), get_y())
        return;
    }

    if ch == 'a' {
        set_mode(MODE_INSERT)
        move(1, 0)
        return;
    }

    if ch == 'A' {
        set_mode(MODE_INSERT)
        move(strlen(get_line()), 0)
        return;
    }

    if ch == 'o' {
        set_mode(MODE_INSERT)
        insert_empty_line(get_y() + 1)
        move(0, 1)
        apply_brace_indent()
        return;
    }

    if ch == 'O' {
        set_mode(MODE_INSERT)
        insert_empty_line()
        apply_brace_indent()
        return;
    }

    if ch == 'e' {
        move_to(get_next_word_x(), get_y())
        last_char = ' '
        return;
    }

    if ch == 'b' {
        move_to(get_prev_word_x(), get_y())
        last_char = ' '
        return;
    }

    if get_mode() == MODE_VISUAL_LINE {
        if ch == 'd' or ch == 'c' {
            a := get_vstart_y()

            b := get_y()

            if a > b {
                temp := b
                b = a
                a = temp
            }

            for i := a; i <= b; i += 1 {
                remove_line(a)
            }

            move_to(0, a)

            if ch == 'd' { 
                set_mode(MODE_NORMAL)
            } else {
                set_mode(MODE_INSERT)
                apply_brace_indent()
            }
            return;
        }     
    } else if ch == 'd' {
        if last_char == 'd' {
            if line_count() > 1 remove_line()
            last_char = ' '
        } else {
            last_char = ch
        }

        return;
    }

    if ch == 'c' {
        if last_char == 'c' {
            start_x := strspn(get_line(), " ")

            remove_line()
            set_mode(MODE_INSERT)
            insert_empty_line()

            for i := 0; i < start_x; i += 1 {
                insert_char(' ')
                move(1, 0)
            }
        } else {
            last_char = 'c'
        }
    }

    if ch == 'h' {
        move_reset(-1, 0)
    } else if ch == 'j' {
        move_reset(0, 1)
    } else if ch == 'k' {
        move_reset(0, -1)
    } else if ch == 'l' {
        move_reset(1, 0)
    } 

    if ch == 127 {
        start_x := get_prev_word_x()

        while get_x() > start_x {
            remove_char()
            move_reset(-1, 0)
        }
    }

    if ch == 'x' {
        if get_line() != "" {
            remove_char()
            if get_x() >= strlen(get_line()) move(-1, 0)
        }
    }
 
    if ch == '{' {
        done := false
        for i := get_y() - 1; i >= 0 and not done; i -= 1 {
            if get_line(i) == "" {
                move(0, i - get_y())
                done = true
            }
        }
        
        if not done {
            move(0, -line_count())
        }
    } else if ch == '}' {
        done := false
        for i := get_y() + 1; i < line_count() and not done; i += 1 {
            if get_line(i) == "" {
                move(0, i - get_y())
                done = true
            }
        }
        
        if not done {
            move(0, line_count())
        }
    }
    
    if ch == 'G' {
        move_reset(0, line_count())
        set_status("To the bottom!")
    } else if ch == 'g' {
        if last_char == 'g' {
            set_status("To the top!")
            move_reset(0, -line_count())
        } else {
            last_char = 'g'
        }
    } 

    if ch == 'r' {
        last_char = 'r'
    }
}

func update_insert_mode() {
    ch := read_char()

    if ch == 27 {
        set_mode(MODE_NORMAL)
    } else if ch == 8 {
        // backspace
        if get_x() == 0 {
            if get_y() > 0 {
                s := get_line()

                move_to(0, get_y() - 1)
                move(strlen(get_line()), 0)

                insert_string(s)
                remove_line(get_y() + 1)
            }
        } else {
            // if there's only spaces before us, maybe we can move back by
            // tab width
            spaces_only := strspn(get_line(), " ") == get_x()

            if not spaces_only {
                move(-1, 0)
                remove_char()
            } else {
                spaces := get_x() - floor((get_x() - 1) / spaces_per_tab) * spaces_per_tab

                for i := 0; i < spaces; i += 1 {
                    move(-1, 0)
                    remove_char()
                }
            }
        }
    } else if ch == 10 {
        x := get_x()
        
        if x == strlen(get_line()) {
            insert_empty_line(get_y() + 1)
            move(0, 1)
        } else {
            rest := get_line_from(get_x()) 
            move(0, 1)

            insert_empty_line()
            insert_string(rest)

            terminate_line(get_y() - 1, x)
        }
        apply_brace_indent()
    } else if ch > 0 {
        if ch == 9 {
            spaces := ceil((get_x() + 1) / spaces_per_tab) * spaces_per_tab - get_x()

            for i := 0; i < spaces; i += 1 {
                insert_char(' ')
            }

            move(spaces, 0)
        } else {
            insert_char(ch)
            move(1, 0)

            if ch == '}' {
                line := get_line()
                if stridx(line, strspn(line, " ")) == '}' {
                    // Spaces all the way 
                    spaces := (count_braces_down(get_y()) - 1) * spaces_per_tab

                    if spaces >= 0 {
                        terminate_line(get_y(), spaces + 1)
                        move_to(spaces, get_y())
                        set_char('}')
                        move(1, 0)
                    }
                }
            }
        }
    }
}

func update() {
    if get_mode() == MODE_INSERT update_insert_mode()
    else if get_mode() == MODE_NORMAL or get_mode() == MODE_VISUAL_LINE update_normal_mode()
}
